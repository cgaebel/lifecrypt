Lifecrypt stores your encrypted personal root of trust. Some examples of what
to include in it are 2fa keys and password manager master keys.

Lifecrypt supports two operations on this data:

`lifecrypt view` prints the stored data to stdout.
`lifecrypt edit` opens up an editor for you to modify the stored data.

Key-derivation is provided by scrypt. Encryption and authentication is provided
ChaCha20Poly1305.

Threat Model
------------
The on-disk data is available to the attacker. They would like to read it.
The attacker is likely a friend or family member, or someone with access to
them.

Or the file could be leaked onto the internet, and a smart 14-year kid with a
lot of free time will try disproportionally hard to break into it.

The attacker does not have access to the computer on which the file is stored
at the time it's edited or viewed. They only have access well after the fact.

Constraints
-----------
It needs to be easy to interpret the file even if the code that would do that
has entirely rotted. Even if there's no rust compiler in the future, the words
in this document and a copy of the file should be enough to decrypt it.

A human has to enter the password to unlock the file. The password only needs
to be proivided once per edit/view.

Disk Format
-----------
The on-disk format is a single JSON object with the following keys:

salt: Base64 encoded 32 bytes, as a salt to use with scrypt.
nonce: Base64 encoded 24 bytes, as a nonce to use with ChaCha20Poly1305.
ciphertext: Base64 encoded ciphertext, as generated by ChaCha20Poly1305.

Base64's alphabet is "[A-Z][a-b][0-9]+/.". It's defined more explicitly in
Section 3 of RFC3548. Lifecrypt does not produce padding.

This would look something like:

{ "salt": "abcdefg",
  "nonce": "ABC123abc",
  "ciphertext": "1234"
}

Decoding
--------
To decode the encrypted data, you must know the password, salt,
and nonce. Then,

key = scrypt(password, salt, log_n=20, r=8, p=1)
plaintext = secretbox::open(disk.ciphertext, disk.nonce, key)

Encoding
--------
Encoding directly follows from the decoding process:

password = get_password_input()
plaintext = get_plaintext()
salt = random_bytes(32)
key = scrypt(password, salt, log_n=20, r=8, p=1)
nonce = random_bytes(24)
ciphertext = secretbox::seal(plaintext, nonce, key)